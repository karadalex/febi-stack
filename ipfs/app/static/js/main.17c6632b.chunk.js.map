{"version":3,"sources":["components/fhir/FHIR.js","components/eth/Ethereum.js","components/bdb/BDB.js","components/app/App.js","serviceWorker.js","index.js","components/ipfs/IPFS.js"],"names":["FHIR","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","fhirData","_this2","window","client","serviceUrl","auth","type","api","search","query","subject","then","r","console","log","setState","setFhirData","react_default","a","createElement","className","JSON","stringify","Component","Ethereum","web3","Web3","givenProvider","BDB","bdbTx","propsChangeStatus","prevProps","ipfsFileHash","alice","driver","tx","makeCreateTransaction","resourceType","data","id","metadata","config","what","created_at","Date","now","updated_at","makeOutput","makeEd25519Condition","publicKey","txSigned","signTransaction","privateKey","postTransactionCommit","res","App","setIpfsFileHash","hash","fhir_FHIR","IPFS","bdb_BDB","eth_Ethereum","Boolean","location","hostname","match","ReactDOM","render","components_app_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister","ipfs","require","ipfsClient","host","port","protocol","_home_karadalex_workspace_febi_stack_frontend_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","_home_karadalex_workspace_febi_stack_frontend_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_home_karadalex_workspace_febi_stack_frontend_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","version","protocol_version","added_file_hash","added_file_contents","err","agentVersion","protocolVersion","_this3","fhirDataString","add","Buffer","from","cat","file","toString","react__WEBPACK_IMPORTED_MODULE_5___default"],"mappings":"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","file":"static/js/main.17c6632b.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\n\nclass FHIR extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      fhirData: {}\n    }\n  }\n\n  componentDidMount() {\n    // FHIR is globally loaded in index.js and can be accessed from the window variable\n    var smart = window.FHIR.client({\n      serviceUrl: 'https://r2.smarthealthit.org',\n      auth: {\n        type: 'none'\n      }\n    });\n  \n    smart.api.search({type: \"Observation\", query: {subject: \"99912345\"}\n      }).then((r) => {\n         console.log(r);\n         this.setState({\n           fhirData: r\n         })\n         this.props.setFhirData(this.state.fhirData);\n      });\n  }\n\n  render() {\n    return (\n      <div className=\"fhir\">\n        <h2>FHIR Data</h2>\n        <pre>\n          {JSON.stringify(this.state.fhirData, null, 2)}\n        </pre>\n      </div>\n    );\n  }\n}\n\nexport default FHIR;\n","import React, { Component } from 'react';\nimport Web3 from 'web3';\n\n\nclass Ethereum extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n\n    componentDidMount() {\n        window.web3 = new Web3(Web3.givenProvider || \"ws://localhost:8546\");\n    }\n\n    render() {\n        return (\n            <div className=\"fhir\">\n                <h2> Ethereum </h2>\n            </div>\n        );\n    }\n}\n\nexport default Ethereum;\n","import React, { Component } from 'react';\nimport * as driver from 'bigchaindb-driver';\n\nclass BDB extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            bdbTx: {},\n            // propsChangeStatus - Finite State Machine explanation\n            // If there is no change in either fhirData prop or ipfsFileHash prop\n            // then propsChangeStatus=0\n            // if first change is in fhirData prop then propsChangeStatus=1\n            // if first change is in ipfsFileHash prop then propsChangeStatus=2\n            // if second change is in fhirData prop and propsChangeStatus=1 then propsChangeStatus=1\n            // if second change is in ipfsFileHash prop and propsChangeStatus=1 then propsChangeStatus=3\n            // if second change is in fhirData prop and propsChangeStatus=2 then propsChangeStatus=3\n            // if second change is in ipfsFileHash prop and propsChangeStatus=2 then propsChangeStatus=2\n            propsChangeStatus: 0\n        }\n    }\n\n    // Execute BigchainDB transaction when new FHIR data are loaded\n    componentDidUpdate(prevProps) {\n        // Use propsChangeStatus variable to make sure that both fhirData\n        // and ipfsFileHash props are changed/updated\n        switch (this.state.propsChangeStatus) {\n            case 0:\n                if (this.props.fhirData !== prevProps.fhirData) {\n                    this.setState({ propsChangeStatus: 1 })\n                }\n                if (this.props.ipfsFileHash !== prevProps.ipfsFileHash) {\n                    this.setState({ propsChangeStatus: 2 })\n                }\n                break;\n            case 1:\n                if (this.props.fhirData !== prevProps.fhirData) {\n                    this.setState({ propsChangeStatus: 1 })\n                }\n                if (this.props.ipfsFileHash !== prevProps.ipfsFileHash) {\n                    this.setState({ propsChangeStatus: 3 })\n                }\n                break;\n            case 2:\n                if (this.props.fhirData !== prevProps.fhirData) {\n                    this.setState({ propsChangeStatus: 3 })\n                }\n                if (this.props.ipfsFileHash !== prevProps.ipfsFileHash) {\n                    this.setState({ propsChangeStatus: 2 })\n                }\n                break;\n            case 3:\n                // BigchainDB server instance (e.g. https://example.com/api/v1/)\n                const API_PATH = 'https://test.bigchaindb.com/api/v1/'\n\n                // Create a new keypair.\n                const alice = new driver.Ed25519Keypair()\n\n                // Construct a transaction payload\n                const tx = driver.Transaction.makeCreateTransaction(\n                    // Define the asset to store\n                    {\n                        resourceType: this.props.fhirData.data.resourceType,\n                        id: this.props.fhirData.data.id,\n                        metadata: this.props.fhirData.config,\n                        ipfsFileHash: this.props.ipfsFileHash\n                    },\n\n                    // Metadata contains information about the transaction itself\n                    {\n                        what: 'FHIR BigchainDB transaction',\n                        created_at: Date.now(),\n                        updated_at: Date.now()\n                    },\n\n                    // A transaction needs an output\n                    [ \n                        driver.Transaction.makeOutput(\n                            driver.Transaction.makeEd25519Condition(alice.publicKey)\n                        )\n                    ],\n                    alice.publicKey\n                )\n\n                // Sign the transaction with private keys\n                const txSigned = driver.Transaction.signTransaction(tx, alice.privateKey)\n\n                // Send the transaction off to BigchainDB\n                let conn = new driver.Connection(API_PATH)\n\n                conn.postTransactionCommit(txSigned)\n                    .then(res => {\n                        console.log('Transaction', txSigned.id, 'accepted')\n                        this.setState({\n                        bdbTx: txSigned\n                        })\n                    })\n\n                // Reset propsChangeStatus\n                this.setState({ propsChangeStatus: 0 })\n                break;\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"App\">\n                <h2>BigchainDB Transaction</h2>\n                <pre>\n                    {JSON.stringify(this.state.bdbTx, null, 2)}\n                </pre>\n            </div>\n        );\n    }\n}\n\nexport default BDB;\n","import React, { Component } from 'react';\nimport './App.css';\nimport FHIR from '../fhir/FHIR';\nimport Ethereum from '../eth/Ethereum';\nimport BDB from '../bdb/BDB';\nimport IPFS from '../ipfs/IPFS';\n\n\nclass App extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            fhirData: {},\n            bdbTx: {},\n            ipfsFileHash: \"\"\n        }\n    }\n\n    setFhirData = (data) => {\n        this.setState({ fhirData: data });\n    }\n\n    setIpfsFileHash = (hash) => {\n        this.setState({ ipfsFileHash: hash })\n        console.log(this.state.ipfsFileHash)\n    }\n\n    render() {\n        return (\n            <div className=\"App\">\n                <h1>FHIR Frontend </h1>\n                <FHIR setFhirData={this.setFhirData}></FHIR>\n                <br></br>\n                <IPFS fhirData={this.state.fhirData} setIpfsFileHash={this.setIpfsFileHash}></IPFS>\n                <br></br>\n                <BDB fhirData={this.state.fhirData} ipfsFileHash={this.state.ipfsFileHash}></BDB>\n                <br></br>\n                <Ethereum></Ethereum>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/app/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, { Component } from 'react';\n\nconst ipfsClient = require('ipfs-http-client')\nconst ipfs = ipfsClient({\n    host: 'ipfs.infura.io',\n    port: '5001',\n    protocol: 'https'\n})\n\nclass IPFS extends Component {\n    constructor (props) {\n        super(props)\n        this.state = {\n            id: null,\n            version: null,\n            protocol_version: null,\n            added_file_hash: null,\n            added_file_contents: null\n        }\n    }\n\n    componentDidMount () {\n        ipfs.id((err, res) => {\n            if (err) throw err\n            this.setState({\n                id: res.id,\n                version: res.agentVersion,\n                protocol_version: res.protocolVersion\n            })\n        })\n    }\n\n    componentDidUpdate(prevProps) {\n        if (this.props.fhirData !== prevProps.fhirData) {\n            var fhirDataString = JSON.stringify(this.props.fhirData);\n            ipfs.add([Buffer.from(fhirDataString)], (err, res) => {\n                if (err) throw err\n                const hash = res[0].hash\n                this.setState({added_file_hash: hash})\n                this.props.setIpfsFileHash(this.state.added_file_hash)\n                ipfs.cat(hash, (err, file) => {\n                    if (err) throw err\n                    let data = file.toString('utf8')\n                    this.setState({added_file_contents: data})\n                })\n            })\n        }\n    }\n\n    render () {\n        return (\n            <div>\n                <h2>IPFS Files</h2>\n                <p>File ID: <strong>{this.state.id}</strong></p>\n                <p>IPFS version: <strong>{this.state.version}</strong></p>\n                <p>IPFS protocol version: <strong>{this.state.protocol_version}</strong></p>\n                <div>\n                    <div>\n                    File was added<br />\n                    {this.state.added_file_hash}\n                    </div>\n                    <div>\n                    Contents of file added: <br />\n                    {this.state.added_file_contents}\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default IPFS;\n"],"sourceRoot":""}